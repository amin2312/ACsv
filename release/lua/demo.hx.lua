-- Generated by Haxe 3.4.7
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["acsv"] = _hx_exports["acsv"] or _hx_e()
local Array = _hx_e()
local Demo = _hx_e()
local Math = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local acsv = {}
acsv.Field = _hx_e()
acsv.Table = _hx_e()
local haxe = {}
haxe.Json = _hx_e()
haxe.Log = _hx_e()
haxe.format = {}
haxe.format.JsonParser = _hx_e()
haxe.io = {}
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self,0);
end
Array.prototype = _hx_a(
  'concat', function(self,a) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    local ret = _g;
    local _g3 = 0;
    while (_g3 < a.length) do 
      local i1 = a[_g3];
      _g3 = _g3 + 1;
      ret:push(i1);
      end;
    do return ret end
  end,
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'shift', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local ret = self[0];
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[i] = self[i + 1];
      end;
    local tmp = self;
    tmp.length = tmp.length - 1;
    do return ret end
  end,
  'indexOf', function(self,x,fromIndex) 
    local _end = self.length;
    if (fromIndex == nil) then 
      fromIndex = 0;
    else
      if (fromIndex < 0) then 
        fromIndex = self.length + fromIndex;
        if (fromIndex < 0) then 
          fromIndex = 0;
        end;
      end;
    end;
    local _g1 = fromIndex;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (x == self[i]) then 
        do return i end;
      end;
      end;
    do return -1 end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

Demo.new = {}
Demo.main = function() 
  Demo._tab1 = acsv.Table.Parse(Demo.standard_format_text);
  Demo._tab2 = acsv.Table.Parse(Demo.enhanced_format_text);
  Demo.showTable("standard csv format",Demo._tab1);
  Demo.test_standard_csv_format();
  Demo.showTable("[E] enhanced csv format",Demo._tab2);
  Demo.test_enhanced_csv_format();
end
Demo.showTable = function(fileName,csvTable) 
end
Demo.P = function(cmd,o) 
  haxe.Log.trace(cmd,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Demo.hx",lineNumber=120,className="Demo",methodName="P"}));
  if (o == nil) then 
    haxe.Log.trace(nil,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Demo.hx",lineNumber=123,className="Demo",methodName="P"}));
  else
    haxe.Log.trace(o,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Demo.hx",lineNumber=127,className="Demo",methodName="P"}));
  end;
end
Demo.test_standard_csv_format = function() 
  Demo.P("select ALL to rows",Demo._tab1:selectAll():toRows());
  Demo.P("select ALL to objs",Demo._tab1:selectAll():toObjs());
  Demo.P("select first row",Demo._tab1:selectFirstRow():toFirstRow());
  Demo.P("select first obj",Demo._tab1:selectFirstRow():toFirstObj());
  Demo.P("select last row",Demo._tab1:selectLastRow():toFirstRow());
  Demo.P("select last obj",Demo._tab1:selectLastRow():toFirstObj());
  Demo.P("selectWhenE (id) = \"2\"",Demo._tab1:selectWhenE(1,"2"):toFirstObj());
  Demo.P("selectWhenE (id) = \"3\" and (id2) = \"21\"",Demo._tab1:selectWhenE2(1,"3","21"):toFirstObj());
  Demo.P("selectWhenE (id) = \"4\" and (id2) = \"21\" and (id3) = \"200\"",Demo._tab1:selectWhenE3(1,"4","21","200"):toFirstObj());
  Demo.P("selectWhenE ALL (id2) = \"20\"",Demo._tab1:selectWhenE(0,"20",1):toObjs());
end
Demo.test_enhanced_csv_format = function() 
  Demo.P("[E] select ALL to rows",Demo._tab2:selectAll():toRows());
  Demo.P("[E] select ALL to objs",Demo._tab2:selectAll():toObjs());
  Demo.P("[E] select first row",Demo._tab2:selectFirstRow():toFirstRow());
  Demo.P("[E] select first obj",Demo._tab2:selectFirstRow():toFirstObj());
  Demo.P("[E] select last row",Demo._tab2:selectLastRow():toFirstRow());
  Demo.P("[E] select last obj",Demo._tab2:selectLastRow():toFirstObj());
  Demo.P("[E] selectWhenE (id) = 2",Demo._tab2:selectWhenE(1,2):toFirstObj());
  Demo.P("[E] selectWhenE (id) = -1",Demo._tab2:selectWhenE(1,-1):toFirstObj());
  Demo.P("[E] selectWhenE2 (id) = 3 and (id2) = 22",Demo._tab2:selectWhenE2(1,3,22):toFirstObj());
  Demo.P("[E] selectWhenE2 (id) = 3 and (id2) = -1",Demo._tab2:selectWhenE2(1,3,-1):toFirstObj());
  Demo.P("[E] selectWhenE3 (id) = 4 and (id2) = 22 and (id3) = 200",Demo._tab2:selectWhenE3(1,4,22,200):toFirstObj());
  Demo.P("[E] selectWhenE3 (id) = 4 and (id2) = 22 and (id3) = -1",Demo._tab2:selectWhenE3(1,4,22,-1):toFirstObj());
  Demo.P("[E] selectWhenE ALL (id2) = 21",Demo._tab2:selectWhenE(0,21,1):toObjs());
  Demo.P("[E] selectWhenE ALL (id2) = -1",Demo._tab2:selectWhenE(0,-1,1):toObjs());
  Demo.P("[E] selectWhenG ALL (id2) > 25",Demo._tab2:selectWhenG(0,false,25,1):toObjs());
  Demo.P("[E] selectWhenG ALL (id2) >= 25",Demo._tab2:selectWhenG(0,true,25,1):toObjs());
  Demo.P("[E] selectWhenG ALL (id2) > 30",Demo._tab2:selectWhenG(0,false,30,1):toObjs());
  Demo.P("[E] selectWhenL ALL (id2) < 22",Demo._tab2:selectWhenL(0,false,22,1):toObjs());
  Demo.P("[E] selectWhenL ALL (id2) <= 22",Demo._tab2:selectWhenL(0,true,22,1):toObjs());
  Demo.P("[E] selectWhenL ALL (id2) < 20",Demo._tab2:selectWhenL(0,true,20,1):toObjs());
  Demo.P("[E] selectWhenGreaterAndLess ALL (id2) > 21 and (id2) < 24",Demo._tab2:selectWhenGreaterAndLess(0,false,false,21,24,1):toObjs());
  Demo.P("[E] selectWhenGreaterAndLess ALL (id2) >= 21 and (id2) <= 24",Demo._tab2:selectWhenGreaterAndLess(0,true,true,21,24,1):toObjs());
  Demo.P("[E] selectWhenLessOrGreater ALL (id2) < 22 or (id2) > 25",Demo._tab2:selectWhenLessOrGreater(0,false,false,22,25,1):toObjs());
  Demo.P("[E] selectWhenLessOrGreater ALL (id2) <= 22 or (id2) >= 25",Demo._tab2:selectWhenLessOrGreater(0,true,true,22,25,1):toObjs());
  Demo.P("[E] selectWhenIn (id) in 3,4,5",Demo._tab2:selectWhenIn(1,_hx_tab_array({[0]=3, 4, 5 }, 3)):toObjs());
  Demo.P("[E] selectAt rows at 0,1,10",Demo._tab2:selectAt(_hx_tab_array({[0]=0, 1, 10 }, 3)):toObjs());
  Demo.P("[E] multi selects (id3) = 100 and (id2) < 22",Demo._tab2:selectWhenE(0,100,2):selectWhenL(0,false,22,1):toObjs());
  Demo.P("[E] sort by (id3) = 300 desc (id)",Demo._tab2:selectWhenE(0,300,2):sortBy(0,1):toObjs());
  Demo._tab2:createIndexAt(0);
  Demo.P("[E] (indexed) Dwi's row",Demo._tab2:selectWhenE(1,"Dwi",Demo._tab2:getColIndexBy("name")):toObjs()[0].name);
  Demo.P("[E] (indexed) 99th row",Demo._tab2:selectWhenE(1,99):toObjs());
end

Math.new = {}
Math.isNaN = function(f) 
  do return f ~= f end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'indexOf', function(self,str,startIndex) 
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then 
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'substring', function(self,startIndex,endIndex) 
    if (endIndex == nil) then 
      endIndex = self.length;
    end;
    if (endIndex < 0) then 
      endIndex = 0;
    end;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
    if (endIndex < startIndex) then 
      do return _G.string.sub(self,endIndex + 1,startIndex) end;
    else
      do return _G.string.sub(self,startIndex + 1,endIndex) end;
    end;
  end,
  'charAt', function(self,index) 
    do return _G.string.sub(self,index + 1,index + 1) end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not ((x > -_G.math.huge) and (x < _G.math.huge)) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x,"^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = x:substr(digitMatch.length);
  local decimalMatch = _G.string.match(x,"^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = x:substr(decimalMatch.length);
  local eMatch = _G.string.match(x,"^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(digitMatch .. decimalMatch .. eMatch);
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new()
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = _hx_e();
  self.length = 0;
end

StringTools.new = {}
StringTools.replace = function(s,sub,by) 
  do return s:split(sub):join(by) end;
end

acsv.Field.new = function() 
  local self = _hx_new()
  acsv.Field.super(self)
  return self
end
acsv.Field.super = function(self) 
end
_hx_exports["acsv"]["Field"] = acsv.Field

acsv.Table.new = function() 
  local self = _hx_new(acsv.Table.prototype)
  acsv.Table.super(self)
  return self
end
acsv.Table.super = function(self) 
  self._selected = nil;
  self._indexSet = _hx_e();
  self.body = Array.new();
  self.head = Array.new();
  self.content = nil;
end
_hx_exports["acsv"]["Table"] = acsv.Table
acsv.Table.Parse = function(content,filedSeparator,filedMultiLineDelimiter) 
  if (filedMultiLineDelimiter == nil) then 
    filedMultiLineDelimiter = "\"";
  end;
  if (filedSeparator == nil) then 
    filedSeparator = ",";
  end;
  local table = acsv.Table.arrayToRows(acsv.Table.textToArray(content,filedSeparator,filedMultiLineDelimiter));
  table.content = content;
  do return table end;
end
acsv.Table.textToArray = function(text,FS,FML) 
  if (FML == nil) then 
    FML = "\"";
  end;
  if (FS == nil) then 
    FS = ",";
  end;
  local FMLs = FML .. FML;
  local array = _hx_tab_array({ }, 0);
  local maxLen = text.length;
  local ptr = text;
  local ptrPos = 0;
  while (true) do 
    local curLen = maxLen - ptrPos;
    local cellIndexA = 0;
    local cellIndexB = 0;
    local cells = _hx_tab_array({ }, 0);
    local cell;
    local chr;
    while (cellIndexB < curLen) do 
      cellIndexA = cellIndexB;
      chr = ptr:charAt(ptrPos + cellIndexB);
      if ((chr == "\n") or (chr == "\r\n")) then 
        cellIndexB = cellIndexB + 1;
        break;
      end;
      if ((chr == "\r") and (ptr:charAt((ptrPos + cellIndexB) + 1) == "\n")) then 
        cellIndexB = cellIndexB + 2;
        break;
      end;
      if (chr == FS) then 
        cell = "";
        local nextPos = (ptrPos + cellIndexB) + 1;
        if (nextPos >= maxLen) then 
          chr = "\n";
        else
          chr = ptr:charAt(nextPos);
        end;
        if ((((cellIndexA == 0) or (chr == FS)) or (chr == "\n")) or (chr == "\r\n")) then 
          cellIndexB = cellIndexB + 1;
          cells:push("");
        else
          if ((chr == "\r") and (ptr:charAt((ptrPos + cellIndexB) + 2) == "\n")) then 
            cellIndexB = cellIndexB + 2;
            cells:push("");
          else
            cellIndexB = cellIndexB + 1;
          end;
        end;
      else
        if (chr == FML) then 
          cellIndexB = cellIndexB + 1;
          local _hx_break_2 = false;
          while (true) do 
            repeat 
            cellIndexB = ptr:indexOf(FML,ptrPos + cellIndexB);
            if (cellIndexB == -1) then 
              haxe.Log.trace("[ACsv] Invalid Double Quote",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Table.hx",lineNumber=716,className="acsv.Table",methodName="textToArray"}));
              do return nil end;
            end;
            cellIndexB = cellIndexB - ptrPos;
            if (ptr:charAt((ptrPos + cellIndexB) + 1) == FML) then 
              cellIndexB = cellIndexB + 2;
              break;
            end;
            _hx_break_3 = true; break;
            
          until true
          if _hx_break_3 then _hx_break_3 = false; break; end
          end;
          cell = ptr:substring((ptrPos + cellIndexA) + 1,ptrPos + cellIndexB);
          cell = StringTools.replace(cell,FMLs,FML);
          cells:push(cell);
          cellIndexB = cellIndexB + 1;
        else
          local indexA = ptr:indexOf(FS,ptrPos + cellIndexB);
          if (indexA == -1) then 
            indexA = curLen;
          else
            indexA = indexA - ptrPos;
          end;
          local indexB = ptr:indexOf("\r\n",ptrPos + cellIndexB);
          if (indexB == -1) then 
            indexB = ptr:indexOf("\n",ptrPos + cellIndexB);
            if (indexB == -1) then 
              indexB = curLen;
            else
              indexB = indexB - ptrPos;
            end;
          else
            indexB = indexB - ptrPos;
          end;
          cellIndexB = indexA;
          if (indexB < indexA) then 
            cellIndexB = indexB;
          end;
          cell = ptr:substring(ptrPos + cellIndexA,ptrPos + cellIndexB);
          cells:push(cell);
        end;
      end;
      end;
    array:push(cells);
    ptrPos = ptrPos + cellIndexB;
    if (ptrPos >= maxLen) then 
      break;
    end;
    end;
  do return array end;
end
acsv.Table.arrayToRows = function(array) 
  local head = array:shift();
  local body = array;
  local fileds = Array.new();
  local _g1 = 0;
  local _g = head.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local fullName = head[i];
    local parts = fullName:split(":");
    local filed = acsv.Field.new();
    filed.fullName = fullName;
    filed.name = parts[0];
    filed.type = parts[1];
    fileds:push(filed);
    end;
  local _g11 = 0;
  local _g2 = body.length;
  while (_g11 < _g2) do 
    _g11 = _g11 + 1;
    local i1 = _g11 - 1;
    local row = body[i1];
    local _g3 = 0;
    local _g21 = row.length;
    while (_g3 < _g21) do 
      _g3 = _g3 + 1;
      local j = _g3 - 1;
      local type = fileds[j].type;
      local cell = row[j];
      local newVal = cell;
      local isEmptyCell = (cell == nil) or (cell == "");
      if (type == "bool") then 
        if ((isEmptyCell or (cell == "false")) or (cell == "0")) then 
          newVal = false;
        else
          newVal = true;
        end;
      else
        if (type == "int") then 
          if (isEmptyCell) then 
            newVal = 0;
          else
            newVal = Std.parseInt(newVal);
          end;
        else
          if (type == "number") then 
            if (isEmptyCell) then 
              newVal = 0.0;
            else
              newVal = Std.parseFloat(newVal);
            end;
          else
            if (type == "json") then 
              if (isEmptyCell) then 
                newVal = nil;
              else
                local chr0 = cell:charAt(0);
                if (not ((chr0 == "[") or (chr0 == "{"))) then 
                  haxe.Log.trace("[ACsv] Invalid json format:" .. fileds[j].name .. "," .. cell,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Table.hx",lineNumber=860,className="acsv.Table",methodName="arrayToRows"}));
                  do return nil end;
                end;
                newVal = cell;
              end;
            else
              if (type == "strings") then 
                if (isEmptyCell) then 
                  newVal = "[]";
                else
                  newVal = "[\"" .. cell:split(","):join("\",\"") .. "\"]";
                end;
              end;
            end;
          end;
        end;
      end;
      row[j] = newVal;
      end;
    body[i1] = row;
    end;
  local table = acsv.Table.new();
  table.head = fileds;
  table.body = body;
  do return table end;
end
acsv.Table.prototype = _hx_a(
  'merge', function(self,b) 
    self.body = self.body:concat(b.body);
    local index = b.content:indexOf("\r\n");
    if (index == -1) then 
      index = b.content:indexOf("\n");
    end;
    local c = b.content:substring(index);
    local tmp = self;
    tmp.content = tmp.content .. c;
  end,
  'createIndexAt', function(self,colIndex) 
    local map = _hx_e();
    local _g1 = 0;
    local _g = self.body.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = self.body[i];
      local key = row[colIndex];
      map[key] = row;
      end;
    self._indexSet[colIndex] = map;
  end,
  'getColIndexBy', function(self,name) 
    local _g1 = 0;
    local _g = self.head.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local field = self.head[i];
      if (field.name == name) then 
        do return i end;
      end;
      end;
    do return -1 end
  end,
  'sortBy', function(self,colIndex,sortType) 
    local len = self._selected.length;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local _g3 = 0;
      local _g2 = len - 1;
      while (_g3 < _g2) do 
        _g3 = _g3 + 1;
        local j = _g3 - 1;
        local ok = false;
        local a = self._selected[j][colIndex];
        local b = self._selected[j + 1][colIndex];
        if ((sortType == 0) and (a > b)) then 
          ok = true;
        else
          if ((sortType == 1) and (a < b)) then 
            ok = true;
          end;
        end;
        if (ok) then 
          local temp = self._selected[j];
          self._selected[j] = self._selected[j + 1];
          self._selected[j + 1] = temp;
        end;
        end;
      end;
    do return self end
  end,
  'getCurrentSelector', function(self) 
    do return self._selected end
  end,
  'fmtRow', function(self,row) 
    local obj = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g = self.head.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local type = self.head[i].type;
      local val0 = row[i];
      local val1 = nil;
      if (((type ~= nil) and (type ~= "")) and (acsv.Table.JSON_TYPES:indexOf(type) ~= -1)) then 
        if (val0 ~= nil) then 
          val1 = haxe.Json.parse(val0);
        end;
      else
        val1 = val0;
      end;
      obj:push(val1);
      end;
    do return obj end
  end,
  'fmtObj', function(self,row) 
    local obj = _hx_e();
    local _g1 = 0;
    local _g = self.head.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local name = self.head[i].name;
      local type = self.head[i].type;
      local val0 = row[i];
      local val1 = nil;
      if (((type ~= nil) and (type ~= "")) and (acsv.Table.JSON_TYPES:indexOf(type) ~= -1)) then 
        if (val0 ~= nil) then 
          val1 = haxe.Json.parse(val0);
        end;
      else
        val1 = val0;
      end;
      obj[name] = val1;
      end;
    do return obj end
  end,
  'toFirstRow', function(self) 
    local rzl = nil;
    if ((self._selected ~= nil) and (self._selected.length > 0)) then 
      rzl = self:fmtRow(self._selected[0]);
    end;
    self._selected = nil;
    do return rzl end
  end,
  'toLastRow', function(self) 
    local rzl = nil;
    if ((self._selected ~= nil) and (self._selected.length > 0)) then 
      rzl = self:fmtRow(self._selected[self._selected.length - 1]);
    end;
    self._selected = nil;
    do return rzl end
  end,
  'toRows', function(self) 
    if (self._selected == nil) then 
      do return nil end;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = self._selected.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = self._selected[i];
      dst:push(self:fmtRow(row));
      end;
    self._selected = nil;
    do return dst end
  end,
  'toFirstObj', function(self) 
    local rzl = nil;
    if ((self._selected ~= nil) and (self._selected.length > 0)) then 
      rzl = self:fmtObj(self._selected[0]);
    end;
    self._selected = nil;
    do return rzl end
  end,
  'toLastObj', function(self) 
    local rzl = nil;
    if ((self._selected ~= nil) and (self._selected.length > 0)) then 
      rzl = self:fmtObj(self._selected[self._selected.length - 1]);
    end;
    self._selected = nil;
    do return rzl end
  end,
  'toObjs', function(self) 
    if (self._selected == nil) then 
      do return nil end;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = self._selected.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = self._selected[i];
      dst:push(self:fmtObj(row));
      end;
    self._selected = nil;
    do return dst end
  end,
  'toTable', function(self) 
    if (self._selected == nil) then 
      do return nil end;
    end;
    local t = acsv.Table.new();
    t.head = self.head:concat(_hx_tab_array({ }, 0));
    t.body = self._selected;
    self._selected = nil;
    do return t end
  end,
  'selectAll', function(self) 
    self._selected = self.body;
    do return self end
  end,
  'selectFirstRow', function(self) 
    self._selected = _hx_tab_array({[0]=self.body[0] }, 1);
    do return self end
  end,
  'selectLastRow', function(self) 
    self._selected = _hx_tab_array({[0]=self.body[self.body.length - 1] }, 1);
    do return self end
  end,
  'selectAt', function(self,rowIndices) 
    local dst = Array.new();
    local _g1 = 0;
    local _g = rowIndices.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local rowIndex = rowIndices[i];
      if ((rowIndex >= 0) and (rowIndex < self.body.length)) then 
        dst:push(self.body[rowIndex]);
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenIn', function(self,limit,values,colIndex) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local rows = Array.new();
    local _g1 = 0;
    local _g = values.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local value = values[i];
      self:selectWhenE(limit,value,colIndex,rows);
      self._selected = nil;
      end;
    self._selected = rows;
    do return self end
  end,
  'selectWhenE', function(self,limit,value,colIndex,extraSelector) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local dst = extraSelector;
    if (dst == nil) then 
      dst = Array.new();
    end;
    if (limit == 1) then 
      local map = self._indexSet[colIndex];
      if (map ~= nil) then 
        local val = map[value];
        if (val ~= nil) then 
          dst:push(val);
        end;
        self._selected = dst;
        do return self end;
      end;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      if (row[colIndex] == value) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenE2', function(self,limit,value1,value2,colIndex2,colIndex1) 
    if (colIndex1 == nil) then 
      colIndex1 = 0;
    end;
    if (colIndex2 == nil) then 
      colIndex2 = 1;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      if ((row[colIndex1] == value1) and (row[colIndex2] == value2)) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenE3', function(self,limit,value1,value2,value3,colIndex3,colIndex2,colIndex1) 
    if (colIndex1 == nil) then 
      colIndex1 = 0;
    end;
    if (colIndex2 == nil) then 
      colIndex2 = 1;
    end;
    if (colIndex3 == nil) then 
      colIndex3 = 2;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      if (((row[colIndex1] == value1) and (row[colIndex2] == value2)) and (row[colIndex3] == value3)) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenG', function(self,limit,withEqu,value,colIndex) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      local rowVal = row[colIndex];
      if ((rowVal > value) or (withEqu and (rowVal == value))) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenL', function(self,limit,withEqu,value,colIndex) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      local rowVal = row[colIndex];
      if ((rowVal < value) or (withEqu and (rowVal == value))) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenGreaterAndLess', function(self,limit,GWithEqu,LWithEqu,GValue,LValue,colIndex) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      local rowVal = row[colIndex];
      local v1 = (rowVal > GValue) or (GWithEqu and (rowVal == GValue));
      local v2 = (rowVal < LValue) or (LWithEqu and (rowVal == LValue));
      if (v1 and v2) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end,
  'selectWhenLessOrGreater', function(self,limit,LWithEqu,GWithEqu,LValue,GValue,colIndex) 
    if (colIndex == nil) then 
      colIndex = 0;
    end;
    local src = self._selected;
    if (src == nil) then 
      src = self.body;
    end;
    local dst = Array.new();
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local row = src[i];
      local rowVal = row[colIndex];
      local v1 = (rowVal < LValue) or (LWithEqu and (rowVal == LValue));
      local v2 = (rowVal > GValue) or (GWithEqu and (rowVal == GValue));
      if (v1 or v2) then 
        dst:push(row);
        limit = limit - 1;
        if (limit == 0) then 
          break;
        end;
      end;
      end;
    self._selected = dst;
    do return self end
  end
)

haxe.Json.new = {}
haxe.Json.parse = function(text) 
  do return haxe.format.JsonParser.new(text):parseRec() end;
end

haxe.Log.new = {}
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.format.JsonParser.new = function(str) 
  local self = _hx_new(haxe.format.JsonParser.prototype)
  haxe.format.JsonParser.super(self,str)
  return self
end
haxe.format.JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
haxe.format.JsonParser.prototype = _hx_a(
  'parseRec', function(self) 
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      local c1 = c;
      if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then 
      elseif (c1) == 34 then 
        do return self:parseString() end;
      elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then 
        local c2 = c;
        local start = self.pos - 1;
        local minus = c2 == 45;
        local digit = not minus;
        local zero = c2 == 48;
        local point = false;
        local e = false;
        local pm = false;
        local _end = false;
        while (true) do 
          local index1 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          c2 = _G.string.byte(self.str,index1 + 1);
          local c3 = c2;
          if (c3) == 43 or (c3) == 45 then 
            if (not e or pm) then 
              self:invalidNumber(start);
            end;
            digit = false;
            pm = true;
          elseif (c3) == 46 then 
            if (minus or point) then 
              self:invalidNumber(start);
            end;
            digit = false;
            point = true;
          elseif (c3) == 48 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
              zero = true;
            end;
            digit = true;
          elseif (c3) == 49 or (c3) == 50 or (c3) == 51 or (c3) == 52 or (c3) == 53 or (c3) == 54 or (c3) == 55 or (c3) == 56 or (c3) == 57 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
            end;
            digit = true;
            zero = false;
          elseif (c3) == 69 or (c3) == 101 then 
            if ((minus or zero) or e) then 
              self:invalidNumber(start);
            end;
            digit = false;
            e = true;else
          if (not digit) then 
            self:invalidNumber(start);
          end;
          self.pos = self.pos - 1;
          _end = true; end;
          if (_end) then 
            break;
          end;
          end;
        local f = Std.parseFloat(self.str:substr(start,self.pos - start));
        local i = Std.int(f);
        if (i == f) then 
          do return i end;
        else
          do return f end;
        end;
      elseif (c1) == 91 then 
        local arr = _hx_tab_array({ }, 0);
        local comma = nil;
        while (true) do 
          local index2 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c4 = _G.string.byte(self.str,index2 + 1);
          local c5 = c4;
          if (c5) == 9 or (c5) == 10 or (c5) == 13 or (c5) == 32 then 
          elseif (c5) == 44 then 
            if (comma) then 
              comma = false;
            else
              self:invalidChar();
            end;
          elseif (c5) == 93 then 
            if (comma == false) then 
              self:invalidChar();
            end;
            do return arr end;else
          if (comma) then 
            self:invalidChar();
          end;
          self.pos = self.pos - 1;
          arr:push(self:parseRec());
          comma = true; end;
          end;
      elseif (c1) == 102 then 
        local save = self.pos;
        local tmp;
        local tmp1;
        local tmp2;
        local index3 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index3 + 1) == 97) then 
          local index4 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp2 = _G.string.byte(self.str,index4 + 1) ~= 108;
        else
          tmp2 = true;
        end;
        if (not tmp2) then 
          local index5 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp1 = _G.string.byte(self.str,index5 + 1) ~= 115;
        else
          tmp1 = true;
        end;
        if (not tmp1) then 
          local index6 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp = _G.string.byte(self.str,index6 + 1) ~= 101;
        else
          tmp = true;
        end;
        if (tmp) then 
          self.pos = save;
          self:invalidChar();
        end;
        do return false end;
      elseif (c1) == 110 then 
        local save1 = self.pos;
        local tmp3;
        local tmp4;
        local index7 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index7 + 1) == 117) then 
          local index8 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp4 = _G.string.byte(self.str,index8 + 1) ~= 108;
        else
          tmp4 = true;
        end;
        if (not tmp4) then 
          local index9 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp3 = _G.string.byte(self.str,index9 + 1) ~= 108;
        else
          tmp3 = true;
        end;
        if (tmp3) then 
          self.pos = save1;
          self:invalidChar();
        end;
        do return nil end;
      elseif (c1) == 116 then 
        local save2 = self.pos;
        local tmp5;
        local tmp6;
        local index10 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index10 + 1) == 114) then 
          local index11 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp6 = _G.string.byte(self.str,index11 + 1) ~= 117;
        else
          tmp6 = true;
        end;
        if (not tmp6) then 
          local index12 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp5 = _G.string.byte(self.str,index12 + 1) ~= 101;
        else
          tmp5 = true;
        end;
        if (tmp5) then 
          self.pos = save2;
          self:invalidChar();
        end;
        do return true end;
      elseif (c1) == 123 then 
        local obj = _hx_e();
        local field = nil;
        local comma1 = nil;
        while (true) do 
          local index13 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c6 = _G.string.byte(self.str,index13 + 1);
          local c7 = c6;
          if (c7) == 9 or (c7) == 10 or (c7) == 13 or (c7) == 32 then 
          elseif (c7) == 34 then 
            if (comma1) then 
              self:invalidChar();
            end;
            field = self:parseString();
          elseif (c7) == 44 then 
            if (comma1) then 
              comma1 = false;
            else
              self:invalidChar();
            end;
          elseif (c7) == 58 then 
            if (field == nil) then 
              self:invalidChar();
            end;
            obj[field] = self:parseRec();
            field = nil;
            comma1 = true;
          elseif (c7) == 125 then 
            if ((field ~= nil) or (comma1 == false)) then 
              self:invalidChar();
            end;
            do return obj end;else
          self:invalidChar(); end;
          end;else
      self:invalidChar(); end;
      end;
  end,
  'parseString', function(self) 
    local start = self.pos;
    local buf = nil;
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      if (c == 34) then 
        break;
      end;
      if (c == 92) then 
        if (buf == nil) then 
          buf = StringBuf.new();
        end;
        local s = self.str;
        local len = (self.pos - start) - 1;
        local part = (function() 
          local _hx_1
          if (len == nil) then 
          _hx_1 = s:substr(start); else 
          _hx_1 = s:substr(start,len); end
          return _hx_1
        end )();
        _G.table.insert(buf.b,part);
        local buf1 = buf;
        buf1.length = buf1.length + part.length;
        local index1 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c = _G.string.byte(self.str,index1 + 1);
        local c1 = c;
        if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
          _G.table.insert(buf.b,_G.string.char(c));
          local buf2 = buf;
          buf2.length = buf2.length + 1;
        elseif (c1) == 98 then 
          _G.table.insert(buf.b,_G.string.char(8));
          local buf3 = buf;
          buf3.length = buf3.length + 1;
        elseif (c1) == 102 then 
          _G.table.insert(buf.b,_G.string.char(12));
          local buf4 = buf;
          buf4.length = buf4.length + 1;
        elseif (c1) == 110 then 
          _G.table.insert(buf.b,_G.string.char(10));
          local buf5 = buf;
          buf5.length = buf5.length + 1;
        elseif (c1) == 114 then 
          _G.table.insert(buf.b,_G.string.char(13));
          local buf6 = buf;
          buf6.length = buf6.length + 1;
        elseif (c1) == 116 then 
          _G.table.insert(buf.b,_G.string.char(9));
          local buf7 = buf;
          buf7.length = buf7.length + 1;
        elseif (c1) == 117 then 
          local uc = Std.parseInt("0x" .. self.str:substr(self.pos,4));
          local tmp = self;
          tmp.pos = tmp.pos + 4;
          if (uc <= 127) then 
            _G.table.insert(buf.b,_G.string.char(uc));
            local buf8 = buf;
            buf8.length = buf8.length + 1;
          else
            if (uc <= 2047) then 
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(192,_hx_bit.arshift(uc,6))));
              local buf9 = buf;
              buf9.length = buf9.length + 1;
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
              local buf10 = buf;
              buf10.length = buf10.length + 1;
            else
              if (uc <= 65535) then 
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(224,_hx_bit.arshift(uc,12))));
                local buf11 = buf;
                buf11.length = buf11.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf12 = buf;
                buf12.length = buf12.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf13 = buf;
                buf13.length = buf13.length + 1;
              else
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(240,_hx_bit.arshift(uc,18))));
                local buf14 = buf;
                buf14.length = buf14.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,12),63))));
                local buf15 = buf;
                buf15.length = buf15.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf16 = buf;
                buf16.length = buf16.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf17 = buf;
                buf17.length = buf17.length + 1;
              end;
            end;
          end;else
        _G.error("Invalid escape sequence \\" .. _G.string.char(c) .. " at position " .. (self.pos - 1),0); end;
        start = self.pos;
      else
        if (c == nil) then 
          _G.error("Unclosed string",0);
        end;
      end;
      end;
    if (buf == nil) then 
      do return self.str:substr(start,(self.pos - start) - 1) end;
    else
      local s1 = self.str;
      local len1 = (self.pos - start) - 1;
      local part1 = (function() 
        local _hx_2
        if (len1 == nil) then 
        _hx_2 = s1:substr(start); else 
        _hx_2 = s1:substr(start,len1); end
        return _hx_2
      end )();
      _G.table.insert(buf.b,part1);
      local buf18 = buf;
      buf18.length = buf18.length + part1.length;
      do return _G.table.concat(buf.b) end;
    end;
  end,
  'invalidChar', function(self) 
    self.pos = self.pos - 1;
    _G.error("Invalid char " .. _G.string.byte(self.str,self.pos + 1) .. " at position " .. self.pos,0);
  end,
  'invalidNumber', function(self,start) 
    _G.error("Invalid number at position " .. start .. ": " .. self.str:substr(start,self.pos - start),0);
  end
)

haxe.io.Eof.new = function() 
  local self = _hx_new(haxe.io.Eof.prototype)
  haxe.io.Eof.super(self)
  return self
end
haxe.io.Eof.super = function(self) 
end
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  Demo.standard_format_text = "id,id2,id3,name,brief\r\n1,20,100,John,He is a googd man\r\n2,20,100,,\"\r\n\"\r\n3,21,100,,\"  \r\n   \r\n :\r\n\"\" \"\"\"\r\n4,21,200,, \r\n5,22,200,,\r\n6,22,200,,"
  Demo.enhanced_format_text = "id:int,id2:int,id3:int,name:string,weight:number,marry:bool,education:json,tags:strings,brief\r\n1,21,100,John,120.1,true,\"[\"\"AB\"\"]\",\"good,cool\",\"Today is good day\r\nTomorrow is good day too\"\r\n2,21,100,,121.2,false,\"[\"\"CD\"\",\"\"EF\"\"]\",good,\r\n3,22,100,,123.4,true,\"[\"\"GH\"\",\"\"AB\"\",\"\"CD\"\"]\",good,\"  \r\n   \"\r\n4,22,200,,124.5,false,\"{\"\"AA\"\":12}\",strong, \r\n5,23,200,,126.7,1,\"{\"\"BB\"\":12}\",strong,\r\n6,23,200,Emilia,,0,\"{\"\"CC\"\":34,\"\"DD\"\":56}\",\"strong,cool\",Hoje  um bom dia\r\n7,24,300,Aye,128.9,0,\"{\"\"EE\"\":34,\"\"FF\"\":56}\",\"strong,cool\",Bugn gzel bir gn\r\n8,24,300,,129.01,,\"{\"\"AC\"\":78,\"\"BD\"\":[90,12]}\",\"height,strong\",\r\n9,25,300,Dwi,130.12,1,\"{\"\"EF\"\":78,\"\"CF\"\":[90,12]}\",,\"Hari ini adalah hari yang baik\r\nBesok juga hari yang baik\"\r\n10,25,400,Bo,131.23,1,\"[\"\"BC\"\",{\"\"AT\"\":34}]\",\"thin,good\",\r\n11,26,400,,132.34,0,\"[\"\"FG\"\",{\"\"AG\"\":34}]\",\"hot,thin,good\",  \r\n12,26,400,,133.456,0,,,"
  acsv.Table.JSON_TYPES = _hx_tab_array({[0]="json", "strings" }, 2)
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
end

_hx_print = print or (function() end)
_hx_static_init();
Demo.main()
return _hx_exports
