// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Std = function() { };
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var acsv_Field = function() {
};
var acsv_Table = function() {
	this._indexed = { };
	this.body = [];
	this.head = [];
};
acsv_Table.Parse = function(content) {
	var table = acsv_Table.arrayToRows(acsv_Table.textToArray(content));
	table.content = content;
	return table;
};
acsv_Table.textToArray = function(text) {
	var array = [];
	var ptr = text;
	var maxLen = text.length;
	if(HxOverrides.substr(text,maxLen - 1,1) == ",") {
		text += "\r\n";
	}
	var ptrPos = 0;
	while(true) {
		var curLen = maxLen - ptrPos;
		var cellBoundA = 0;
		var cellBoundB = 0;
		var cells = [];
		var cell;
		var chr;
		while(cellBoundB < curLen) {
			cellBoundA = cellBoundB;
			chr = ptr.charAt(ptrPos + cellBoundB);
			if(chr == "\n" || chr == "\r\n") {
				++cellBoundB;
				break;
			}
			if(chr == "\r" && ptr.charAt(ptrPos + cellBoundB + 1) == "\n") {
				cellBoundB += 2;
				break;
			}
			if(chr == ",") {
				cell = "";
				chr = ptr.charAt(ptrPos + cellBoundB + 1);
				if(cellBoundA == 0 || chr == "," || chr == "\n" || chr == "\r\n") {
					++cellBoundB;
					cells.push("");
				} else if(chr == "\r" && ptr.charAt(ptrPos + cellBoundB + 2) == "\n") {
					cellBoundB += 2;
					cells.push("");
				} else {
					++cellBoundB;
				}
			} else if(chr == "\"") {
				++cellBoundB;
				while(true) {
					cellBoundB = ptr.indexOf("\"",ptrPos + cellBoundB);
					if(cellBoundB == -1) {
						throw new js__$Boot_HaxeError("Invalid Double Quote");
					}
					if(ptr.charAt(ptrPos + cellBoundB + 1) == "\"") {
						cellBoundB += 2;
						continue;
					}
					break;
				}
				cell = ptr.substring(ptrPos + cellBoundA + 1,ptrPos + cellBoundB);
				cell = StringTools.replace(cell,"\"\"","\"");
				cells.push(cell);
				++cellBoundB;
			} else {
				var indexA = ptr.indexOf(",",ptrPos + cellBoundB);
				if(indexA == -1) {
					indexA = curLen;
				}
				var indexB = ptr.indexOf("\r\n",ptrPos + cellBoundB);
				if(indexB == -1) {
					indexB = ptr.indexOf("\n",ptrPos + cellBoundB);
				}
				if(indexB == -1) {
					indexB = curLen;
				}
				cellBoundB = indexA;
				if(indexB < indexA) {
					cellBoundB = indexB;
				}
				cell = ptr.substring(ptrPos + cellBoundA,ptrPos + cellBoundB);
				cells.push(cell);
			}
		}
		array.push(cells);
		ptrPos += cellBoundB;
		if(ptrPos >= maxLen) {
			break;
		}
	}
	return array;
};
acsv_Table.arrayToRows = function(array) {
	var head = array.shift();
	var body = array;
	var i;
	var len;
	var j;
	var lenJ;
	var fileds = [];
	var _g1 = 0;
	var _g = head.length;
	while(_g1 < _g) {
		var i1 = _g1++;
		var pair = head[i1].split(":");
		var filed = new acsv_Field();
		filed.name = pair[0];
		filed.type = pair[1];
		fileds.push(filed);
	}
	var _g11 = 0;
	var _g2 = body.length;
	while(_g11 < _g2) {
		var i2 = _g11++;
		var row = body[i2];
		var _g3 = 0;
		var _g21 = row.length;
		while(_g3 < _g21) {
			var j1 = _g3++;
			var type = fileds[j1].type;
			var cell = row[j1];
			var newVal = cell;
			var isEmptyCell = cell == null || cell == "";
			switch(type) {
			case "array":
				if(isEmptyCell) {
					newVal = "[]";
				} else {
					newVal = "[" + cell + "]";
				}
				break;
			case "bool":
				if(isEmptyCell || cell == "false") {
					newVal = false;
				} else {
					newVal = true;
				}
				break;
			case "int":
				if(isEmptyCell) {
					newVal = 0;
				} else {
					newVal = Std.parseInt(newVal);
				}
				break;
			case "json":
				if(isEmptyCell) {
					newVal = null;
				} else {
					newVal = cell;
				}
				break;
			case "number":
				if(isEmptyCell) {
					newVal = 0;
				} else {
					newVal = parseFloat(newVal);
				}
				break;
			case "object":
				if(isEmptyCell) {
					newVal = "{}";
				} else {
					newVal = "{" + cell + "}";
				}
				break;
			case "strings":
				if(isEmptyCell) {
					newVal = "[]";
				} else {
					newVal = "[\"" + cell.split(",").join("\",\"") + "\"]";
				}
				break;
			}
			row[j1] = newVal;
		}
		body[i2] = row;
	}
	var table = new acsv_Table();
	table.head = fileds;
	table.body = body;
	return table;
};
acsv_Table.prototype = {
	merge: function(b) {
		this.body = this.body.concat(b.body);
		var index = b.content.indexOf("\r\n");
		if(index == -1) {
			index = b.content.indexOf("\n");
		}
		var c = b.content.substring(index);
		this.content += c;
	}
	,createIndexAt: function(colIndex) {
		var map = { };
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			var key = row[colIndex];
			map[key] = row;
		}
		this._indexed[colIndex] = map;
	}
	,rowToObj: function(row) {
		var name;
		var type;
		var val;
		var obj = { };
		var _g1 = 0;
		var _g = this.head.length;
		while(_g1 < _g) {
			var i = _g1++;
			name = this.head[i].name;
			type = this.head[i].type;
			val = row[i];
			if(type != null && type != "" && acsv_Table.JSON_TYPES.indexOf(type) != -1) {
				obj[name] = JSON.parse(val);
			} else {
				obj[name] = val;
			}
		}
		return obj;
	}
	,rowsToObjs: function(rows) {
		var objs = [];
		var _g1 = 0;
		var _g = rows.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = rows[i];
			objs.push(this.rowToObj(row));
		}
		return objs;
	}
	,toFirstObj: function() {
		return this.rowToObj(this._lastSelectd);
	}
	,toObjs: function() {
		return this.rowsToObjs(this._lastSelectd);
	}
	,selectAll: function() {
		this._lastSelectd = this.body;
		return this._lastSelectd;
	}
	,selectFirstRow: function() {
		this._lastSelectd = this.body[0];
		return this._lastSelectd;
	}
	,selectLastRow: function() {
		this._lastSelectd = this.body[this.body.length - 1];
		return this._lastSelectd;
	}
	,selectOneWhenE: function(value,colIndex) {
		this._lastSelectd = null;
		var map = this._indexed[colIndex];
		if(map != null) {
			this._lastSelectd = map[value];
			return this._lastSelectd;
		}
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] == value) {
				this._lastSelectd = row;
				return this._lastSelectd;
			}
		}
		return this._lastSelectd;
	}
	,selectOneWhenE2: function(value1,value2,colIndex2,colIndex1) {
		if(colIndex1 == null) {
			colIndex1 = 0;
		}
		if(colIndex2 == null) {
			colIndex2 = 1;
		}
		this._lastSelectd = null;
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex1] == value1 && row[colIndex2] == value2) {
				this._lastSelectd = row;
				return this._lastSelectd;
			}
		}
		return this._lastSelectd;
	}
	,selectOneWhenE3: function(value1,value2,value3,colIndex3,colIndex2,colIndex1) {
		if(colIndex1 == null) {
			colIndex1 = 0;
		}
		if(colIndex2 == null) {
			colIndex2 = 1;
		}
		if(colIndex3 == null) {
			colIndex3 = 1;
		}
		this._lastSelectd = null;
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex1] == value1 && row[colIndex2] == value2 && row[colIndex3] == value3) {
				this._lastSelectd = row;
				return this._lastSelectd;
			}
		}
		return this._lastSelectd;
	}
	,selectRowWhenNear: function(value,nearType,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		this._lastSelectd = null;
		var rowIndex = 0;
		var cellVal;
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			rowIndex = i;
			cellVal = row[colIndex];
			var isNear = false;
			if(value < 0) {
				if(nearType == 0) {
					isNear = value == cellVal;
				} else if(nearType == 1) {
					isNear = value < cellVal;
				} else if(nearType == 2) {
					isNear = value <= cellVal;
				} else if(nearType == 3) {
					isNear = value > cellVal;
				} else if(nearType == 2) {
					isNear = value >= cellVal;
				}
				if(isNear) {
					break;
				}
			} else {
				if(nearType == 0) {
					isNear = value == cellVal;
				} else if(nearType == 1) {
					isNear = value > cellVal;
				} else if(nearType == 2) {
					isNear = value >= cellVal;
				} else if(nearType == 3) {
					isNear = value < cellVal;
				} else if(nearType == 2) {
					isNear = value <= cellVal;
				}
				if(isNear) {
					break;
				}
			}
		}
		this._lastSelectd = this.body[rowIndex];
		return this._lastSelectd;
	}
	,selectRowsWhenE: function(value,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] == value) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenE2: function(value1,value2,colIndex2,colIndex1) {
		if(colIndex1 == null) {
			colIndex1 = 0;
		}
		if(colIndex2 == null) {
			colIndex2 = 1;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex1] == value1 && row[colIndex2] == value2) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenE3: function(value1,value2,value3,colIndex3,colIndex2,colIndex1) {
		if(colIndex1 == null) {
			colIndex1 = 0;
		}
		if(colIndex2 == null) {
			colIndex2 = 1;
		}
		if(colIndex3 == null) {
			colIndex3 = 2;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex1] == value1 && row[colIndex2] == value2 && row[colIndex3] == value3) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenG: function(value,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] > value) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenGE: function(value,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] >= value) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenL: function(value,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] < value) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
	,selectRowsWhenLE: function(value,colIndex) {
		if(colIndex == null) {
			colIndex = 0;
		}
		var rows = [];
		var _g1 = 0;
		var _g = this.body.length;
		while(_g1 < _g) {
			var i = _g1++;
			var row = this.body[i];
			if(row[colIndex] <= value) {
				rows.push(row);
			}
		}
		this._lastSelectd = rows;
		return this._lastSelectd;
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
acsv_Table.JSON_TYPES = ["json","object","array","strings"];
acsv_Table.CompareTypeEqual = 0;
acsv_Table.CompareTypeGreater = 1;
acsv_Table.CompareTypeGreaterOrEqual = 2;
acsv_Table.CompareTypeLess = 3;
acsv_Table.CompareTypeLessOrEqual = 4;
})();
